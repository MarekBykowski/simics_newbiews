/*
  Â© 2021 Intel Corporation

  This software and the related documents are Intel copyrighted materials, and
  your use of them is governed by the express license under which they were
  provided to you ("License"). Unless the License provides otherwise, you may
  not use, modify, copy, publish, distribute, disclose or transmit this software
  or the related documents without Intel's prior written permission.

  This software and the related documents are provided as is, with no express or
  implied warranties, other than those that are expressly stated in the License.
*/

/*
----------------------------------------------------------------------------------

  m-compute : Mandelbrot fractal compute device, in DML 
            : Part of Simics training materials

*/


dml 1.4;

device m_compute;

param desc = "mandelbrot compute unit";

param documentation = "Compute unit for the mandelbrot hardware accelerator";

import "utility.dml";
import "simics/devs/signal.dml";
import "simics/devs/memory-space.dml";
import "simics/simulator-api.dml";
import "m-compute-control-interface.dml";

loggroup control;      // operations that control the computation
loggroup compute;      // actual compute work
loggroup performance;  // performance

// Type of values the compute computes
typedef  uint16 iter_count_type;

// Dummy vs real implementation of the algorithm
param dummy_implementation = false;

// Enable threaded execution of the algorithm code
// Using a parameter means the code needs to be recompiled to 
// change between parallel and serial mode. 
//
// The code guarded with #if(threaded_compute) in the code
// will be removed while compiling DML and thus no trace of
// threading will be present in the final binary.  
param threaded_compute = false;

// C-level trick to get debug messages pointing at a line in the code
header %{ 
#define S(x) #x
#define S1(x) S(x)
#define __WHERE_AM_I__ (__FILE__ ":" S1(__LINE__))
%} 
extern const char *__WHERE_AM_I__;

//----------------------------------------------------------------------
//
// Callback to get into a threaded context, management of thread-main
// device interactions. 
//
//----------------------------------------------------------------------
import "pthread.dml";

export do_compute_work_callback as "do_compute_work_callback_e";
extern void do_compute_work_callback_e(conf_object_t *);
typedef void (*callback_type)(void *);

// Pass the descriptor to work on to the thread via an object-global variable
// Separate object instances of the compute unit in the Simics simulation all
// get their local copy. 
session work_descriptor_t temp_d;

// Global sync variables
session pthread_mutex_t  worker_thread_lock;
session pthread_cond_t   worker_thread_condvar;
session bool             worker_thread_done;

// Callback from Simics when the thread starts
// This code runs in Simics Thread Context
method do_compute_work_callback() {
    log info, 3, control | compute : "do_compute_work_callback called";
        
    // Do the actual compute work
    do_compute_work(temp_d);

    // Tell the "after" callback that we are well and truly done
    pthread_mutex_lock(&worker_thread_lock);
    worker_thread_done = true;
    pthread_cond_signal(&worker_thread_condvar);
    pthread_mutex_unlock(&worker_thread_lock);
}

// Makes Simics start a worker thread to run the compute job
//
//   Called if threaded_compute is set to true. 
//
method do_compute_work_in_thread(work_descriptor_t d) {
    // Set the object-global descriptor pointer to point at the
    // current job.  One such variable exists for each compute unit
    // object in Simics, so this is safe as long as there is only
    // one compute thread per compute unit object.  Which is the 
    // case here. 
    temp_d = d;

    // Set completion signal BEFORE starting thread = no lock needed
    // to protect this shared variable. 
    worker_thread_done = false;

    // Use the Simics API to call a function in a worker thread provided
    // by the Simics core itself.  
    SIM_run_in_thread(cast(do_compute_work_callback_e,callback_type), dev.obj);
}

// Called from init fucnction for this object. 
method init_thread_sync() {
    worker_thread_done = false;
    pthread_mutex_init(&worker_thread_lock, NULL);
    pthread_cond_init(&worker_thread_condvar, NULL);
}

//----------------------------------------------------------------------
//
// Configuration attributes
//
//----------------------------------------------------------------------
attribute pixel_compute_time is (uint64_attr, init) {
    param documentation = "Time to process one pixel (ps)";
    param configuration = "optional";
    method init() {
      this.val = 10000;  // 10000 ps = 10 ns = device can do 100Mpx/s 
    }
}

attribute individual_pixel_update is (bool_attr, init) {
    param documentation = "Update each pixel at a time";
    param configuration = "optional";
    method init() {
      this.val = false;  // Do not update each pixel at a time
    }
}

attribute is_threaded is (read_only_attr) {
    param documentation = "Is this model compiled to be threaded?";
    param type="b";
    param internal=true;   // do not show in default list-attributes
    method get() -> (attr_value_t ) {
        return (SIM_make_attr_boolean(threaded_compute));
    }
}



//----------------------------------------------------------------------
//
// Connects   
// - Reference to the memory space where we do DMA.
// - Reference to the object to signal completion to. 
//
//----------------------------------------------------------------------
connect local_memory {
    param desc = "Memory space used for work descriptors and results";
    param configuration = "required";
    param internal = false;       // = list-attributes shows it by default
    interface memory_space;
}

// Semantics of operation done:
// - State of this signal should follow the state of the "done" 
//   flag in the status register
connect operation_done {
    param desc = "Object to receive completion notifications";
    param configuration = "optional";  
    param internal = false;       // = list-attributes shows it by default
    interface signal;

    // Signal that the operation completed
    // But only if something is connected
    method signal_done() {
        if(obj) {
            log info, 2, control: "Signalling completion";            
            signal.signal_raise();
        } else {
            log info, 2, control: "No connected object to signal completion to";
        }
    }

    // Lower signal only on clearing the status
    method signal_done_clear() {
        if(obj) {
            log info, 2, control: "Lowering completion signal";            
            signal.signal_lower();
        } else {
            log info, 2, control: "No connected object to signal completion to";
        }
    }
}


//----------------------------------------------------------------------
//
// Ports   
// - Incoming connections. Both methods are wrapped in the same
//   custom interface.  
//   - "start operation": Start a compute operation 
//   - "clear done": Clear the done flag
//
// Having this as a custom interface instead of as two separate
// signal interfaces simplifies the code as well as the setup. 
// And avoids the need to consider raise/lower logic for signals
// that add no value to single "do X" signals like those.  In hardware
// it would be necessary to send in a clock pulse or something, but a
// TLM model can abstract.
//
//----------------------------------------------------------------------
port control_in {
    param desc = "control input from the control unit";

    implement m_compute_control {

        // Start an operation
        method start_operation() {
            log info, 2, control: "Received request to start compute job";
            if (ctrl.status.processing.val == 1) {
                // Getting to this error state requires that the
                // external world calls start_operation() twice without
                // completing the operation in the meantime. 
                log spec_viol, 1, control :
                    "Operation start request while operation in progress";
                return;
            } 

            // Note that it is OK to start a new operation if the device
            // is in state "done".  You can add a test here if you do not
            // think that is a good design.  
            start_compute_job();
        }

        method clear_done() {
            log info, 2, control: "Received request to clear done flag";
            // Sanity check 
            if (ctrl.status.done.val == 0) {
                log spec_viol, 1, control :
                "Clear done signal received when done flag is not set.";
                return;
            }    
            log info, 2, control: "Clearing done flag from signal %s", this.qname;
            do_clear_done();
        }
    }
}

//----------------------------------------------------------------------
//
// Utility, shamelessly borrowed from the sample-dma-device
//
// Read len bytes of target memory from the address src in the memory
// $target_mem_space. The result is put in memory pointed to by dst,
// which must be large enough to hold at least len bytes. If a memory
// access error occurs this method will print an error message and
// throw an exception.
//
//----------------------------------------------------------------------
method read_mem(void *dst,
                physical_address_t src,
                physical_address_t len) throws {
    local exception_type_t exc;
    exc = local_memory.memory_space.access_simple(dev.obj,
                                                src,
                                                dst,
                                                len,
                                                Sim_RW_Read,
                                                Sim_Endian_Target);

    if (exc != Sim_PE_No_Exception) {
        log error: "Error reading target memory";
        throw;
    }
}

//----------------------------------------------------------------------
//
// Memory layout of work descriptor
// -- Design assumes that the actual memory to work in is 
//    right after this header.
//
// And struct used in the computations in the device model
// -- Same data, but converted to host format for computation
//
//----------------------------------------------------------------------
typedef layout "little-endian" {

    // Parameters to define the area to compute
    //   Format is biased to cover the range [-2, 2]
    //   float_value = (uint32_value - 2Gi) / 1Gi
    uint32 bottom;
    uint32 left;
    uint32 top;
    uint32 right;

    // Pixel area to compute over
    uint32 width_px;
    uint32 height_px;

    // Maximum iteration count 
    uint32 max_iter;

    // To put the address field on an 8-byte boundary
    uint32 _reserved;

    // Address to work Area
    uint64 addr_px;

} work_descriptor_layout_t;

typedef struct {

    // Parameters to define the area to compute
    double bottom;
    double left;
    double top;
    double right;

    // Pixel area to compute over
    uint32 width_px;
    uint32 height_px;

    // Maximum iteration count 
    uint32 max_iter;

    // start of pixel block
    physical_address_t addr_px;  

    // Cache some derived values that are used 
    // repeatedly in all computations
    double             width_f;
    double             height_f;
    uint32             count_px;

} work_descriptor_t;

method descriptor_value_to_double(uint32 dvalue) -> (double) {
    // Convert encoding from descriptor to double for 
    // model code to work on. 
    return (cast(dvalue, double) - 0x8000_0000 ) /0x4000_0000;
}

method read_descriptor() -> ( work_descriptor_t ) {
    // Use the layout type to interpret the data read from memory
    local work_descriptor_layout_t desc_mem;
 
    // And the struct type to track values
    local work_descriptor_t d = {0,0,0,0,0,0,0,0,0,0,0};    

    // Compute adddress of layout in the local_memory map
    local physical_address_t desc_addr;
    desc_addr = ctrl.descriptor_addr.val;

    // Read descriptor from memory into model-local storage
    try {
        read_mem(&desc_mem, desc_addr, sizeof desc_mem);
    } catch {
        log error: "Descriptor read failed";
        return d;    // should be all zeroes at this point
    }

    // Pick up values from descriptor
    d.bottom = descriptor_value_to_double( desc_mem.bottom );
    d.left =   descriptor_value_to_double( desc_mem.left   );
    d.top =    descriptor_value_to_double( desc_mem.top    );
    d.right =  descriptor_value_to_double( desc_mem.right  );
    d.width_px = desc_mem.width_px;
    d.height_px = desc_mem.height_px;
    d.max_iter  = desc_mem.max_iter;
    d.addr_px   = desc_mem.addr_px;

    // Derived values
    d.width_f  = d.right - d.left;
    d.height_f = d.top - d.bottom;
    d.count_px = d.width_px * d.height_px;

    // Log what is going on
    log info, 2, compute: "Work descriptor read. Area: (%f, %f) - (%f, %f) (%d, %d) iter: %d pixels  @ 0x%x", 
                           d.bottom, d.left, d.top, d.right, 
                           d.width_px, d.height_px, d.max_iter,
                           d.addr_px;

    return d;
}

//----------------------------------------------------------------------
//
// Device control register bank 
// - The compute unit has as a single register bank 
//
//-----------------------------------------------------------------------------
bank ctrl {
    param desc = "control registers";
    param documentation = "Control register bank for this " +
                          "compute unit.";

    param register_size = 8;
    
    // Pointing at the descriptor in memory
    // Setting register has no side effect
    register descriptor_addr @ 0x00 "Descriptor address";

    // Status register
    register status @ 0x08 "Compute status" {
        field done        @ [63] is (write)       "Compute completed" ;
        field processing  @ [62] is (read_only)   "Compute in progress" ;
        field unused      @ [61:32] is (reserved) "unused" ; 
        field count       @ [31:0] is (read_only) "Processed pixel count" ;
    }
}

//----------------------------------------------------------------------
//
// Register bank implementation  
// - Adding the functionality to the names and offsets declared above
//
//----------------------------------------------------------------------
bank ctrl {
    register status {
        field done is write {
            method write(uint64 v) {
                if (v==1) {
                    if(this.val==1) {
                        do_clear_done();
                    } else {
                        log spec_viol, 1, control: "Attempt to clear already clear done flag";
                    }
                } else {
                    log spec_viol, 1, control: "Writing zero to done has no effect";
                }
            }
        }
    }
}

//----------------------------------------------------------------------
//
// Callback for compute operation completion - from "after" statement
//
//----------------------------------------------------------------------

method compute_operation_complete(work_descriptor_t d) {        
    // Called after the operation has completed
    log info, 2, compute : "Compute operation nominally finished";

    // If threaded, wait to signal operation completion until
    // the compute thread has actually completed the work.  
    //
    // If this callback gets called BEFORE the thread is done, 
    // it will block the entire simulation execution here until
    // the thread has completed.  This might seem a bit clumsy,
    // and an alternative could be to re-post the waiting event
    // for a later time.  However, that would make the target 
    // system behavior change depending on the speed and scheduling
    // of threads on the host, which is not a good idea in general. 
    //
    #if(threaded_compute) {

        // Before using pthread locks, make sure to drop any Simics
        // native locks held by the thread. This is necessary to 
        // avoid deadlocks from mixing two different sets of locks. 
        //
        // Since this code is called from the main Simics execution, 
        // it does hold one or more thread domains.  
        local domain_lock_t * dlt;
        dlt = SIM_drop_thread_domains();

        // Pthread locking, coordinating with the worker thread
        // Standard idiom to wait for another thread to signal
        // a variable. 
        pthread_mutex_lock(&worker_thread_lock);
        while(!worker_thread_done) {
            pthread_cond_wait(&worker_thread_condvar, &worker_thread_lock);
        }
        pthread_mutex_unlock(&worker_thread_lock);

        // Pick up the locks again. 
        SIM_reacquire_thread_domains(dlt);
    }
    
    // Update status register 
    // - count, done, processing  
    ctrl.status.processing.val = 0;
    ctrl.status.count.val = d.count_px;

    // Signal the outbound signal and the done flag
    do_set_done();

    // Signal notifier, for scripting to use 
    SIM_notify(this.obj, complete_notifier);
}

//----------------------------------------------------------------------
//
// Logic for done flag and completion signal
//
//----------------------------------------------------------------------

method do_set_done() {
    log info, 2, control: "Setting done flag";
    operation_done.signal_done();
    ctrl.status.done.val = 1;
}

method do_clear_done() {
    log info, 2, control: "Clearing done flag";
    operation_done.signal_done_clear();
    ctrl.status.done.val = 0;
}

//----------------------------------------------------------------------
//
// Implementation of the compute functionality
//
// - start_compute_job - set up device state, kick off work -
//                       either into a thread or in the same thread
//
// - do_compute_work - perform the actual computation 
//                     which can be in an offload thread
// 
//----------------------------------------------------------------------

method start_compute_job() {
    // Debug log 
    log info, 3, compute : "start_compute_job called";

    // When called, assume that we checked that there is no operation 
    // in progress.  You could use assert, but an error log is nicer
    // as it keeps Simics alive for diagnosis of the problem. 
    if(ctrl.status.processing.val==1) {
        log error, 1, control: 
          "Internal inconsistency - %s called when operation in progress", qname;
        return;
    }

    // Read work descriptor from memory
    local work_descriptor_t d;
    d = read_descriptor();

    // Completion notification after the specified delay
    local double delay;
    delay = cast(pixel_compute_time.val, double) 
                * d.width_px 
                * d.height_px    // number of pixels
                * 1e-12;           // picoseconds conversion
    log info, 2, compute : "Compute operation time: %.10f s", delay;

    // This event is posted from the main execution thread, even 
    // for the threaded case. 
    after delay s: compute_operation_complete(d);

    // Set status register to indicate the operation is starting
    ctrl.status.done.val = 0;
    ctrl.status.processing.val = 1;
    ctrl.status.count.val = 0;

    // Kick off the work
    //   Different function for starting a threaded job. 
    #if(threaded_compute)  {
        log info, 3, performance | compute : "Starting computation in offload thread";
        do_compute_work_in_thread(d);
    } 
    #else {
        log info, 3, compute : "Starting computation inline in main thread";        
        do_compute_work(d);
    }
}


method do_compute_work(work_descriptor_t d) {

    // Variant implementations, controlled via parameter
    if (individual_pixel_update.val==true) {
        compute_each_pixel_to_sim_memory(d);  
    } else {
        compute_in_model_scratch(d);
    }

    // After the compute work completes, if this is run inline, 
    // it will return in the Simics execution thread.  
}

//
// Memory write helper method
// -- Do memory write
// -- Handle errors
// -- Handle thread-safe access to Simics memory & log
//
// Assumes access is to local_memory, with this object as initiator.
//

extern void SIM_ACQUIRE_TARGET(...); 
extern void SIM_RELEASE_TARGET(...); 


method write_memory_block(physical_address_t target_addr, 
                          uint8 *            local_buf, 
                          physical_address_t buf_size) {

    local exception_type_t   exc;
    local domain_lock_t    * dlt;

    // When running in a thread and accessing state in an Simics simulation object,
    // it is necessary to "acquire" the target object. This prevents any other thread
    // from trying to change its state at the same time. 
    // 
    // To call a function in another object, as is done here, SIM_acquire_target()
    // should be used.  In this case, the object pointed to by "local_memory". 
    //
    // The last two arguments are used to provide good information on where locks
    // are being taken for the "print-object-lock-stats" command.  To use that 
    // mechanism, do the following:
    //
    // simics> enable-object-lock-stats
    // simics> r
    // ...
    // running> print-object-lock-stats
    //
    #if(threaded_compute) {
        dlt=SIM_acquire_target(local_memory.obj, "write_memory_block", __WHERE_AM_I__);
    }
    exc = local_memory.memory_space.access_simple(dev.obj,
                                                  target_addr,
                                                  local_buf,
                                                  buf_size,
                                                  Sim_RW_Write,    
                                                  Sim_Endian_Target );
    if (exc != Sim_PE_No_Exception) {
        // The Simics logging API is self-locking. Thus no need to acquire any more
        // locks before logging the error. 
        //
        // For other APIs, a call should be preceded by a call to the SIM_acquire_cell,
        // since the API might touch more than a single object.  It should still only
        // touch objects inside the same cell, though.  
        log error: "Error writing to target memory (address=0x%x, %d bytes)", 
                    target_addr, buf_size ;
    }
    // After the memory operation is finished, release the acquired object.
    #if(threaded_compute) {
        SIM_release_target(local_memory.obj, dlt);    
    }

}

//
//  compute_each_pixel_to_sim_memory 
//  -- set each pixel in memory as soon as it is computed
//  -- generates MANY simulated memory accesses 
//  
method compute_each_pixel_to_sim_memory(work_descriptor_t d) {
    // Pixel iteration
    local int   x = 0;
    local int   y = 0;

 #if (dummy_implementation) {
    // Basic test: color the data 
    for (x=0; x < d.width_px; x++ ) {
        for (y=0; y < d.height_px; y++) {
            local physical_address_t pixaddr;
            pixaddr = (d.addr_px) + (x + y*d.width_px) * sizeoftype iter_count_type ;
            local iter_count_type  pixval  = 0xff00;
            write_memory_block(pixaddr, cast(&pixval,uint8 *), sizeof pixval );
        }
    }
} #else {   // not-dummy implementation 
    for (x=0; x < d.width_px; x++ ) {
        for (y=0; y < d.height_px; y++) {

            local physical_address_t pixaddr;
            pixaddr = (d.addr_px) + (x + y*d.width_px) * sizeoftype iter_count_type ;
            local iter_count_type  pixval  = compute_single_pixel(x,y,d);
            write_memory_block(pixaddr, cast(&pixval,uint8 *), sizeof pixval );
        }
    }
}    

}


//
//  compute_in_model_scratch 
//  -- compute the results in a buffer allocated in the model
//  -- write out complete results to simulated memory 
//
method compute_in_model_scratch(work_descriptor_t d) {
    // Pixel iteration
    local int   x = 0;
    local int   y = 0;

    // Buffer
    local iter_count_type* cb;
    cb =  new iter_count_type[d.count_px];

 #if (dummy_implementation) {
    // Basic test: color the data 
    for (x=0; x < d.width_px; x++ ) {
        for (y=0; y < d.height_px; y++) {
            *(cb + ((x + y*d.width_px) )) = 0xff00;
        }
    }
} #else {   // not-dummy implementation 
    for (x=0; x < d.width_px; x++ ) {
        for (y=0; y < d.height_px; y++) {
            *(cb + ((x + y*d.width_px) )) = compute_single_pixel(x,y,d);
        }
    }
}    

    // Write back  entire block to target memory in one step
    write_memory_block(d.addr_px, 
                       cast(cb,uint8 *), 
                       d.count_px * sizeoftype iter_count_type );

    // clean  up memory allocation 
    delete cb;
}


method compute_single_pixel(int x, int y, work_descriptor_t d) -> (iter_count_type) {
    // 
    local int    iter_count = 0;
    local double x0 = d.left + (cast(x,double) /d.width_px * d.width_f);
    local double y0 = d.top - (cast(y,double) /d.height_px * d.height_f);

    local double xi = 0.0;
    local double yi = 0.0;

    while( (xi*xi + yi*yi < 4.0) && (iter_count < d.max_iter)) {
        local double xi_old = xi;
        local double yi_old = yi;

        xi = xi_old * xi_old - yi_old * yi_old + x0;
        yi = 2 * xi_old * yi_old + y0;
        iter_count ++;
    }

    return iter_count;
}


//----------------------------------------------------------------------
//
// Device initialization 
// 
//----------------------------------------------------------------------
session notifier_type_t complete_notifier;

method init () {

    // -- Runs at device creation time.  
    //    Meaning that is adds the notification to the class quite a 
    //    few times.  However, that is still correct given how the 
    //    notifier API in the Simics simulator works.

    complete_notifier = SIM_notifier_type("m-compute-complete");

    SIM_register_notifier(SIM_get_class(dev.classname),
                            complete_notifier,
                            "Triggered when the compute unit operation completes");

    // Initialize thread synchronization variables
    //   For clarity, the code lives with the rest of the
    //   threading control code earlier in this file. 
    #if(threaded_compute) {
        init_thread_sync();
    }
}


