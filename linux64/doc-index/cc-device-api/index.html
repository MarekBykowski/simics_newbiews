<!doctype html>
<head>
<meta charset=utf-8>
<link rel="stylesheet" href="simics.css">
<title>C++ Device API v2</title>
<script>function postUrl() {
    window.parent.postMessage({ content_url: window.location.href }, "*");
}
if (window.parent != null && window.parent != window) {
    postUrl();
    window.addEventListener("hashchange", function () {
        postUrl();
    });
} else {
    // Check if we are part of a Simics doc site and redirect if we are
    fetch("../simics-doc-site-marker", { method: "HEAD" }).then(response => {
        if (response.ok) {
            window.location = "..#" + window.location.href;
        } else {
            console.info("Not part of a Simics documentation site");
        }
    }).catch(error => {
        console.warn("Failed to check if this is a Simics documentation site:",
            error);
    });
}</script>
</head><body>
<div class=chain>
<span></span>
</div>
<div class=path>
</div>
<h1>C++ Device API v2</h1>

<p>



</p><p>
</p><h2 class="jdocu"><a name="Introduction">1 Introduction</a></h2>
<p>

</p><p>
This document describes the Simics C++ Device API, which is a C++ layer built
on top of the Simics C API. See the <em>Model Builder User's Guide</em> for
more information about the C API. The C++ Device API is also used when
integrating SystemC models into the Simics framework. See the <em>SystemC
Library Programming Guide</em> for more information about Simics and SystemC
models.
</p><p>
We recommend that you use DML for writing new simulation models, but it is
often necessary to port existing simulations models from a different
environment to Simics. If these are written in C++ or SystemC, you can use
the <em>C++ Device API</em> to simplify the task. For SystemC there is further
support described in the <em>SystemC Library Programming Guide</em>.
</p><p>
The Simics C++ Device API is a collection of C++ functions, data types, and
templates that make it easier to connect a C++ simulation model to the Simics
framework. The C++ Device API is implemented as a layer on top of the Simics C
API and its source code can be found in
<code>[simics]/src/devices/c++-api</code>. The
detailed API documentation for the C++ API is available in the
<em>Simics C++ Device API Reference Manual</em>.
</p><p>
While this application note aims to cover most aspects of porting C++ device
models to the Simics APIs, it is assumed that you are familiar with the Simics
device modeling concepts described in the <em>Model Builder User's
Guide</em>.
</p><p>

</p><h2 class="jdocu"><a name="The-Simics-C++-Device-API">2 The Simics C++ Device API</a></h2>
<p>

</p><p>
This Simics C++ Device API aims at replace the old Simics C++ Device API which
is referred as v1 (the first version) in this document. The v1 API was
developed decades ago before the C++11 standard was introduced. It also has
some technical limitations, for example, no support for the Simics port objects.
The new version utilizes C++11 and C++14 to improve productivity, makes it
easier to use and adds support for the Simics port objects. The C++ compiler
needs to support the C++14 standard, therefore the GCC compiler must be of
version 6.3 or higher.
</p><p>
You will need to set <code>USE_CC_API = 2</code> in your module's
<code>Makefile</code>. This makes sure the module can find the necessary new
version C++ API header files and that the C++ API support files are linked
into the module.
</p><p>
The Simics C++ Device API is exported in the C++ namespace <code>simics</code>. To
use it, your C++ files also need to <code>#include &lt;simics/cc-api.h&gt;</code>.
</p><p>
See the provided source code for the module <code>sample-device-c++</code> which
shows how to use the API described in this document.
</p><p>

</p><h2 class="jdocu"><a name="Preparations">3 Preparations</a></h2>
<p>

</p><p>
Before you start to connect your C++ device to the Simics <a name="API">API</a>, you
need to consider which the logical components of your <a name="device">device</a> model
are, and how they are connected to each other and the rest of the simulation
environment.
</p><p>
In Simics, device models are implemented as separate objects that are
dynamically connected to each other using the Simics configuration system, and
the objects communicate using explicitly requested interfaces. This is in
contrast to C++, where the objects are often aggregated at compile time or by
running compiled startup code and interfaces are resolved during compilation
and linking. The <em>Model Builder User's Guide</em> has a more complete
description of the Simics object system.
</p><p>
Just like in C++, the Simics <em><a name="objects">objects</a></em> are instances
of <em><a name="classes">classes</a></em>, but the Simics object classes are dynamically
defined by a Simics <em>module</em> by calling the Simics API to register
callback functions to allocate and deallocate objects, and to
add <em>attributes</em> to the classes.
</p><p>
</p><h3 class="jdocu"><a name="Designing-the-Classes">3.1 Designing the Classes</a></h3>
<p>

</p><p>
The first step is to decide how the C++ model should appear within Simics. For
a simple C++ model that models a small piece of hardware, it is probably
nothing more than saying that the whole model should be a single Simics class.
</p><p>
But for a C++ model that consists of several components connected together, it
is worth considering exposing it as several Simics classes. One reason for this
is that it makes the Simics configuration more natural by creating a model that
fits better with the Simics framework. And it allows for future separation of
the model parts without major changes to the configurations.
</p><p>
Simply exposing the model as several classes will not automatically make the
classes independent under the surface; they are still implemented as one
conglomerate of C++ objects inside the implementation. To fully take advantage
of the flexibility of the Simics configuration system, the device should be
split it to discrete pieces that communicate only using Simics interfaces. By
using well-known interfaces, the devices will become replaceable by newer
implementations individually, and will allow experimentation in reconfiguration
without having to recompile the model sources, or even having access to the
source code.
</p><p>
This document focuses on creating Simics modules wrapping simple C++ models
which define a single Simics class, but it easily extends to modules with
several classes.
</p><p>

</p><h3 class="jdocu"><a name="Defining-Attributes">3.2 Defining Attributes</a></h3>
<p>

<a name="attributes"></a>
</p><p>
A Simics object <em>attribute</em> is used to accomplish primarily
three things. The first is to specify configuration parameters when initially
creating the model instance. This includes connections to other configuration
objects, model parameters such as frequencies and buffer sizes, but anything is
possible.
</p><p>
The other main purpose of attributes is to allow saving and restoring the model
state to support checkpointing and reversibility. This means that the complete
state of the model needs to be available to the Simics configuration system as
attribute values in a well-defined way.
</p><p>
A third use of attributes is for inspection of the state of the model. This is
usually covered by the same attributes used for checkpointing. The
configuration of the model may also use the checkpoint attributes to set an
initial state.
</p><p>
</p><h4 class="jdocu"><a name="Configuration-Attributes">3.2.1 Configuration Attributes</a></h4>
<p>

</p><p>
The configurable aspects of the C++ model should be available as configuration
attributes. In some cases this will mean small changes to the C++
implementation.
</p><p>
The most common configurable parameter is probably references to other Simics
configuration objects, such as interrupt targets, memory spaces or DMA
controllers. The model must never make any assumptions about what other objects
appear in the system configuration. All rest-of-world information must be given
in configuration parameters.
</p><p>
If the C++ model is written with compile-time configuration using the
preprocessor, consider rewriting it to be dynamically reconfigurable. This will
make the model more versatile, and potentially much more useful to a broader
audience. The overhead of runtime checking of these kinds of configuration
parameters is negligible in the vast majority of devices, especially when run
in the context of full-system simulation.
</p><p>
For example, a parameter to decide which hardware revision to be compatible
with may very well be a run-time parameter. Another option is adding
configuration parameters that go outside the scope of the known hardware, by
allowing buffer sizes and similar parameters to be reconfigured for
experimental purposes.
</p><p>

</p><h4 class="jdocu"><a name="Model-State">3.2.2 Model State</a></h4>
<p>

</p><p>
To support checkpointing, the model needs to be able to collect a full
description of the current model state and it needs to be able to restore the
model to the checkpointed state when the Simics object is created.
</p><p>
To support reversible execution, the requirements are stricter. The object
needs to be able to restore from a checkpointed state at any time, even when
there is a previous state that must be discarded.
</p><p>
An existing C++ model needs to be examined to find how its simulation state
is defined. If the model is not written to handle checkpointing, it may need to
be updated with a way to extract and restore the state.
</p><p>
The model state is made available to the Simics configuration system using a
number of attributes. There should be one attribute for each piece of the model
state. It is a good idea to design the set of attributes for the model in a way
that allows some separation of the external, checkpointable representation of
the state from the implementation details. Ideally, the checkpoint format
should not need to be updated when the implementation is changed, including
running on a different host platform, using different C++ classes, internal
representation or other structural changes. As a minimum requirement the
external representation must not depend on what compiler is used, or whether
the model is built for a 32-bit or 64-bit environment. Preferably it should be
fully portable between platforms regardless of what CPU architecture the
simulation is running on. When changes to the checkpoint format is required,
Simics provides ways to still be able to read old checkpoints with updated
models.
</p><p>
For example, if the model models a device with 16 32-bit registers with
different meaning, it is preferably represented as 16 integer-valued
attributes, with names that match those used in the device programming manual.
</p><p>
An example of something to avoid doing is saving a copy of the memory
representation of a C++ object. This is highly unportable and may break
checkpoint compatibility just by recompiling the source with different compiler
flags.
</p><p>


</p><h3 class="jdocu"><a name="Interfaces">3.3 Interfaces</a></h3>
<p>

</p><p>
A Simics device model interacts with the rest of the simulation
using <em>interfaces</em>. The <em>interfaces</em> can either by implemented on
the device model or on a separate <em>port object</em>. There may be several
port objects implementing the same interface.
</p><p>
To be useful, the model should implement one or more interfaces. The most
commonly implemented interface is called <code>io_memory</code> and is used to
simulate memory transactions between processors, devices, and memory.
</p><p>

</p><p>
Finally, the model needs to define a number of <em><a name="attributes2">attributes</a></em>
to support configuration, checkpointing and other Simics features.
</p><p>
For more information about how to design a model for Simics, see
  <em>Model Builder User's Guide</em>.
</p><p>

</p><h2 class="jdocu"><a name="Simics-Modules">4 Simics Modules</a></h2>
<p>

</p><p>
The very first step of building a C++ simulation model for Simics is to create
a Simics module. Usually, you put each Simics class in a model of its own. It
is also possible to make several classes share one model, which may be
necessary if the classes share code.
</p><p>
To create a C++ device model skeleton, you use <code>project-setup</code>:
</p><dl><dt id="dt:windows"><b>Windows</b></dt><dd><pre class="jdocu_small">&gt; <b>cd <em>my-simics-project</em></b>
project&gt; <b>bin\project-setup --c++-device my_cc_device</b></pre><p>
</p></dd><dt id="dt:linux"><b>Linux</b></dt><dd><pre class="jdocu_small">$ <b>cd <em>my-simics-project</em></b>
project$ <b>./bin/project-setup --c++-device my_cc_device</b></pre><p>
</p></dd></dl><p>See the Build Environment chapter in the <em>Model Builder User's
Guide</em> for details on how to set up a project and creating Simics model
skeletons.
</p><p>
As a Simics module is loaded into Simics, it is initialized by running
its <b><i>init_local()</i></b> function, which must use C linkage; i.e., it must
be <code>extern "C"</code>.
</p><p>
This function is in particular responsible for registering all Simics classes
with the Simics core, but you can add any other initialization code needed to
that function.
</p><p>

</p><h2 class="jdocu"><a name="Simics-Classes">5 Simics Classes</a></h2>
<p>

</p><p>
A Simics class has a name, a short description and a documentation string. Its
functionality is implemented in a number of configuration attributes and the
interfaces.
</p><p>
For each instance of a Simics class defined using the C++ API, there will be a
C++ object created to correspond to that Simics configuration object. This C++
object is an instance of a model-defined class that must inherit from
the <code>simics::ConfObject</code> class.
</p><p>
The C++ class must have a constructor taking a single parameter of type
<code>ConfObjectRef</code> which is passed on to the <code>ConfObject</code>
constructor. The C++ class constructor is called internally when the
corresponding Simics configuration object is created. The destructor of the
C++ class is called internally when the corresponding Simics configuration
object is deleted.
</p><p>
In addition of the constructor and destructor, user can override two
methods <b><i>finalize</i></b> and <b><i>objects_finalized</i></b> to register
additional functionality if needed. The <b><i>finalize</i></b> method is called
when all attributes have been initialized in the object, and in all other
objects that are created at the same time. This method is supposed to do any
object initialization that require attribute values. The
<b><i>objects_finalized</i></b> method is called after <b><i>finalize</i></b> has
been called on all objects, so in this method the configuration is ready, and
communication with other objects is permitted without restrictions.
</p><p>
 </p><pre class="jdocu_small">#include &lt;simics/cc-api.h&gt;

class sample_instance : public simics::ConfObject {
  public:
    explicit sample_instance(simics::ConfObjectRef o)
        : simics::ConfObject(o) {
        // initialize
    }

    static void init_class(simics::ConfClass *cls) {
        // register the class properties to Simics
    }

    // other members
};
 </pre><p>

</p><p>
This is the main object of the model instance, and everything goes through
this. It should contain or reference anything that the model instance will
need. Remember that there can be several instances of the model class, since
the configuration allows the user to load multiple systems into the same
simulation.
</p><p>
</p><h3 class="jdocu"><a name="Defining-the-Simics-Class">5.1 Defining the Simics Class</a></h3>
<p>

</p><p>
A class is added to Simics by calling a template function
<b><i>simics::make_class</i></b>. This function is usually called in the
<b><i>init_local</i></b> function.
</p><p>
</p><pre class="jdocu_small">extern "C" void init_local() {
    simics::make_class&lt;sample_instance&gt;(
        // Simics class name
        "sample_device_auto",
        // short description
        "sample C++ device",
        // class documentation
        "This is a sample Simics device written in C++.");
} </pre><p>

</p><p>
The function parameters for <b><i>simics::make_class</i></b> are the
<i>name</i>, the <i>short_desc</i>, and
the <i>description</i>. It also takes an optional forth parameter
<i>kind</i> which by default is <code>Sim_Class_Kind_Vanilla</code>. See
the documentation of <b><i>SIM_create_class</i></b> for more information about
these 4 parameters.
</p><p>
The template argument is the class that should be instantiated to represent the
Simics object. It must be derived through public inheritance from
<code>simics::ConfObject</code> as noted above.
</p><p>
Sometimes it is necessary to know the Simics class that is being registered.
The function returns a <code>unique_ptr</code> of <code>ConfClass</code> which
can be used to register attributes, interfaces, log groups and ports. In the
example above, the return value is not used, and only the class is registered.
</p><p>
If, during registration, the class passed as template argument defines a static
function <b><i>init_class</i></b>; that function is called during the registration.
It is recommended to perform any class related registration of properties
inside this static function, to improve data encapsulation. Other type of
registration can be done inside <b><i>init_local</i></b> using the return value
from <b><i>make_class</i></b>.
</p><p>
</p><pre class="jdocu_small">extern "C" void init_local() {
    auto cls = simics::make_class&lt;sample_instance&gt;(
        "sample_device_explicit",
        "sample C++ device",
        "This is a sample Simics device written in C++.");

    // use cls to do any other registrations necessary
} </pre><p>

</p><p>

</p><p>

</p><h2 class="jdocu"><a name="Attributes">6 Attributes</a></h2>
<p>

</p><p>
Unlike previous C++ API, there is only one way to define attributes. The
attribute is defined by creating an object of type <code>Attribute</code> and
adding it to the <code>ConfClass</code> instance using the <code>add</code>
function.
</p><p>
There are several constructors with different sets of parameters. The following
parameters must be provided for all constructors: a string <i>name</i>,
a string <i>type</i> and a string <i>doc</i>. These parameters
have the same meaning as in <b><i>SIM_register_attribute</i></b>. The
<i>name</i> specifies the attribute name, and must be unique for the
class and stable between revisions of the model. The <i>type</i> is the
type which describes the data type of the attribute, and should also be stable
between revisions of the model to support Simics configuration scripts and
checkpointing. The macro
<code>ATTR_TYPE_STR</code> can be used to auto generate the type string from a C++
variable. The <i>doc</i> describes the attribute.
</p><p>
Get and set callbacks can be registered for the attribute through
<i>getter</i> and <i>setter</i> parameters. For a C++ class
member variable, <code>AttributeAccessor</code> can be used for the
registration. 
</p><p>
There is an optional <i>attr</i> parameter which is one of
<code>Sim_Attr_Required</code>, <code>Sim_Attr_Optional</code> or
<code>Sim_Attr_Pseudo</code>. This can be used to indicate that
an attribute is required (<code>Sim_Attr_Required</code>) or that it should not be
part of checkpoints (<code>Sim_Attr_Pseudo</code>). The default value is
<code>Sim_Attr_Optional</code> if no explicit value is set.
</p><p>
Depending on how the state variable is stored in the C++ class, there are
different ways to register the attribute.
</p><p>
 </p><pre class="jdocu_small">class sample_instance : public simics::ConfObject {
  public:
    explicit sample_instance(simics::ConfObjectRef o)
        : simics::ConfObject(o), value(0) { }

    static void init_class(simics::ConfClass *cls) {
        cls-&gt;add(simics::Attribute("value", "i", "A value.",
                                   ATTR_CLS_VAR(sample_instance, value)));
    }

    int value;
};
                        //...
extern "C" void init_local() {
    simics::make_class&lt;sample_instance&gt;(
            "sample_simple_attrib",
            "simple attribute", "...");
}
</pre><p>

</p><p>
This example uses <code>ATTR_CLS_VAR(sample_instance, value)</code> to locate the
state variable, given an instance of <code>sample_instance</code>. The macro
<code>ATTR_CLS_VAR</code> expands to an <code>AttributeAccessor</code>.
</p><p>
A public state variable member of a C++ build-in type or a C++ standard 
container of build-in type can be registered directly using
<code>ATTR_CLS_VAR</code>. For example, an <code>array</code> of two boolean values.
</p><p>
</p><pre class="jdocu_small">class sample_flag : public simics::ConfObject {
  public:
    explicit sample_flag(simics::ConfObjectRef o)
        : simics::ConfObject(o) { }

    static void init_class(simics::ConfClass *cls) {
        cls-&gt;add(simics::Attribute("flags", "[bb]", "Two boolean flags in a list",
                                   ATTR_CLS_VAR(sample_flag, flags)));
    }

    std::array&lt;bool, 2&gt; flags {false, false};
};

extern "C" void init_local() {
    simics::make_class&lt;sample_flag&gt;(
            "sample_flag",
            "sample flag device",
            "N/A");
}
</pre><p>

</p><p>
If a state variable is not in public scope, indirect access is needed. It is
quite common that a C++ class provides a public get and set function
for its private state variable member. To register the variable as a Simics
attribute, simply wrap the public get and set function pointers using macro
<code>ATTR_GETTER</code> and <code>ATTR_SETTER</code> respectively and pass them as
the parameters to the <code>Attribute</code> constructor.
</p><p>
</p><pre class="jdocu_small">class sample_get_set_attrib : public simics::ConfObject {
  public:
    explicit sample_get_set_attrib(simics::ConfObjectRef o)
        : simics::ConfObject(o), value(0) { }

    static void init_class(simics::ConfClass *cls) {
        cls-&gt;add(simics::Attribute(
                         "value", "i", "A value.",
                         ATTR_GETTER(sample_get_set_attrib, get_value),
                         ATTR_SETTER(sample_get_set_attrib, set_value)));
    }

    int get_value() const;
    void set_value(const int &amp;v);

  private:
    int value;
};

// ...

int sample_get_set_attrib::get_value() const {
    return value;
}

void sample_get_set_attrib::set_value(const int &amp;v) {
    if (v &lt; 256) {
        value = v;
    } else {
        throw std::runtime_error("Too large value");
    }
}

extern "C" void init_local() {
    simics::make_class&lt;sample_get_set_attrib&gt;(
            "sample_get_set_attrib",
            "sample get/set attribute device",
            "N/A");
}
</pre><p>

</p><p>
By wrapping the value with functions, it is also possible to add extra checks.
The getter function simply returns the value. The setter function takes a 
reference to a value, and can accept or reject it by throwing a runtime_error
with a string message describing why it was rejected. The exception is caught
in the Simics attribute setter function and converted to a proper Simics log
message.
</p><p>
The getter and setter functions can be global functions as well. Then they
should take the main C++ object as a function parameter.
</p><p>
</p><pre class="jdocu_small">class sample_proxy_attrib : public simics::ConfObject {
  public:
    explicit sample_proxy_attrib(simics::ConfObjectRef o)
        : simics::ConfObject(o), value(0) { }

    static void init_class(simics::ConfClass *cls);

    void set_hidden_value(int v) { value = v; }
    const int &amp;get_hidden_value() const { return value; }

  private:
    int value;
};

// ...

int get_value(const sample_proxy_attrib &amp;obj) {
    return -obj.get_hidden_value();
}

void set_value(sample_proxy_attrib &amp;obj, const int &amp;v) {
    obj.set_hidden_value(-v);
}

void sample_proxy_attrib::init_class(simics::ConfClass *cls) {
    cls-&gt;add(simics::Attribute("value", "i", "A value.",
                               ATTR_GETTER(get_value),
                               ATTR_SETTER(set_value)));
}

extern "C" void init_local() {
    simics::make_class&lt;sample_proxy_attrib&gt;(
            "sample_proxy_attrib",
            "sample proxy attributes device",
            "N/A");
}
</pre><p>

</p><p>
The same macros, <code>ATTR_GETTER</code> and <code>ATTR_SETTER</code> are used to help
convert getters and setters into the functions required by the Simics attribute.
</p><p>
If the getter is <code>nullptr</code>, it means that the attribute is write-only.
If the setter is <code>nullptr</code>, it means that it is read-only. If either 
is <code>nullptr</code>, the attribute cannot be checkpointed and if
<i>attr</i> is left out, <code>Sim_Attr_Pseudo</code> is automatically
chosen.
</p><p>
</p><h3 class="jdocu"><a name="Creating-Custom-get-and-set-functions">6.1 Creating Custom get and set functions</a></h3>
<p>
  
</p><p>
  The help macros <code>ATTR_CLS_VAR</code>, <code>ATTR_GETTER</code> and
  <code>ATTR_SETTER</code> support all C++ native build-in types or STL containers
  that consist of them. A complete list of equivalent types supported by the
  help macros are listed in the following table. The pointer, the C++ containers
  including <code>array</code>, <code>list</code>, <code>vector</code>, <code>deque</code>,
  <code>pair</code>, <code>map</code>, the <code>enum</code> are supported if the underlying
  type is one of the types listed in the table.
</p><p>
  <span class="jdocu_smaller">
  <table>

    <tbody><tr>
      <td class="jdocu_border"><b>Boolean type</b></td>
      <td class="jdocu_border"><b>Character types</b></td>
      <td class="jdocu_border"><b>Integer types</b></td>
      <td class="jdocu_border"><b>Floating-point types</b></td>
      <td class="jdocu_border"><b>Object type</b></td>
    </tr>

    <tr><td class="jdocu_border"><code>bool</code></td>
        <td class="jdocu_border"><code>char</code>, <code>signed char</code>, <code>unsigned char</code></td>
        <td class="jdocu_border"><code>short int</code>, <code>unsigned short int</code>, <code>int</code>,
          <code>unsigned int</code>, <code>long int</code>, <code>unsigned long int</code>,
          <code>long long int</code>, <code>unsigned long long int</code></td>
        <td class="jdocu_border"><code>float</code>, <code>double</code></td>
        <td class="jdocu_border"><code>simics::ConfObjectRef</code>, <code>simics::Connect</code></td>
    </tr>

  </tbody></table>
  </span>
</p><p>
  </p><div class="note">
<b>Note:</b>
Traditional C-style arrays, or Raw Arrays, are not supported by the help
    macros. Either replace them with C++ <code>array</code>, or use custom get and
    set functions as described below. </div>For other types not listed here, including user defined types, it is possible
  to create custom get and set functions. For example, the model may need to
  use a traditional C-style array of integers. All that is required to perform
  this translation is to create new get and set functions and implement them as
  shown in the example below:
  
 <pre class="jdocu_small">#include &lt;simics/cc-api.h&gt;

class sample_instance : public simics::ConfObject {
  public:
    explicit sample_instance(simics::ConfObjectRef o)
            : simics::ConfObject(o) {
        value[0] = 0;
        value[1] = 0;
    }

    static void init_class(simics::ConfClass *cls);

    int value[2];
};

attr_value_t get_value(conf_object_t *obj) {
    auto *o = simics::from_obj&lt;sample_instance&gt;(obj);
    return SIM_make_attr_list(
            2,
            SIM_make_attr_uint64(o-&gt;value[0]),
            SIM_make_attr_uint64(o-&gt;value[1]));
}

set_error_t set_value(conf_object_t *obj, attr_value_t *attr) {
    auto *o = simics::from_obj&lt;sample_instance&gt;(obj);
    o-&gt;value[0] = SIM_attr_integer(SIM_attr_list_item(*attr, 0));
    o-&gt;value[1] = SIM_attr_integer(SIM_attr_list_item(*attr, 1));
    return Sim_Set_Ok;
}

void sample_instance::init_class(simics::ConfClass *cls) {
    cls-&gt;add(simics::Attribute("value", "[ii]", "A value.",
                               &amp;get_value, &amp;set_value));
}

extern "C" void init_local() {
    simics::make_class&lt;sample_instance&gt;(
            "sample_custom_get_set",
            "sample custom get&amp;set functions", "...");
}
</pre><p>


</p><h3 class="jdocu"><a name="Calling-interfaces-on-connected-configuration-objects">6.2 Calling interfaces on connected configuration objects</a></h3>
<p>
  
</p><p>
  To call a Simics interface on another configuration object, the other object
  must be <code>connected</code> with the current object. This connection
  is represented by having an attribute that points to the other object. The
  attribute is then used to extract the interface pointer used in the interface
  call.
</p><p>
  The template based class <code>Connect</code> performs these two things; it
  defines an attribute that can take an object (explicit registration of
  this attribute is still needed) and it extracts the interfaces requested
  from this object. If the object passed to the attribute does not provide all
  required interfaces a Simics log message is emitted indicating which
  interface is missing and the <b><i>set</i></b> ignores the object passed.
</p><p>
  The following code will create an <i>irq_dev</i> attribute that only
  accepts objects implementing the <code>SignalInterface</code> as a value.
  </p><pre class="jdocu_small">#include &lt;simics/c++/devs/signal.h&gt;

class sample_connect : public simics::ConfObject {
  public:
    explicit sample_connect(simics::ConfObjectRef o);

    static void init_class(simics::ConfClass *cls) {
        cls-&gt;add(simics::Attribute("irq_dev", "o|n",
                                   "IRQ device",
                                   ATTR_CLS_VAR(sample_connect, irq_dev)));
    }

    simics::Connect&lt;simics::iface::SignalInterface&gt; irq_dev;
};
</pre><p>

</p><p>
  If the attribute is set to an object, that object is guaranteed to implement
  the requested interface so using that interfaces is simple:
  </p><pre class="jdocu_small">sample_connect::sample_connect(simics::ConfObjectRef o)
    : simics::ConfObject(o) {
    if (irq_dev) {
        irq_dev.iface().signal_raise();
    }
}
</pre><p>

</p><p>
  To specify multiple interfaces on a configuration object, simply add all
  interface classes as template parameters of <code>Connect</code>.
  </p><pre class="jdocu_small">    simics::Connect&lt;simics::iface::SignalInterface,
                    simics::iface::PulseInterface&gt; target_dev;
  </pre><p>
</p><p>
  The Simics C++ interface struct is fetched through a template based
  function <b><i>iface</i></b>. The template parameter can be omitted when
  fetching the first interface type of the template parameter list.
  </p><pre class="jdocu_small">    if(target_dev) {
        target_dev.iface&lt;simics::iface::PulseInterface&gt;().pulse();
        target_dev.iface().signal_raise();
    }
  </pre><p>


</p><h2 class="jdocu"><a name="Ports-and-Interfaces">7 Ports and Interfaces</a></h2>
<p>

</p><p>
To implement an interface, either on the top level module or a port 
object, there are three steps needed:
</p><dl><dt id="dt:interface-declarations"><b>Interface declarations</b></dt><dd>Declare C++ methods inherited from the interface class.
  </dd><dt id="dt:interface-method-implementation"><b>Interface method implementation</b></dt><dd>Implement the declared C++ methods for the interface.
  </dd><dt id="dt:interface-registration"><b>Interface registration</b></dt><dd>Register the interface with the <code>ConfClass</code> object.
  </dd></dl><p></p><h3 class="jdocu"><a name="Interface-declarations">7.1 Interface declarations</a></h3>
<p>Your instance class needs to declare the C++ methods inherited from
    the interface class.
</p><p>
    For example:
    </p><pre class="jdocu_small">class sample_interface : public simics::ConfObject,
                         public simics::iface::IoMemoryInterface {
  public:
    explicit sample_interface(simics::ConfObjectRef o)
        : simics::ConfObject(o) { }

    static void init_class(simics::ConfClass *cls);

    // interface method declarations
    exception_type_t operation(generic_transaction_t *mem_op,
                               map_info_t map_info) override;
};
</pre><p>

</p><p>
    For a Simics public interface, its C++ interface header is already part
    of the <code>Simics-Base</code> package and can be included directly. For a
    user defined interface, the C++ interface header can be generated from its
    C interface header by a help script. See
    <a class="reference" href="#user-defined-interface">7.4</a>.
</p><p>
    The interface method declarations are straight-forward. They
    should have the same signature as the interface method in the
    <em>Simics Reference Manual</em> (or as shown with the Simics command
    <b>api-help</b>), except that the first C argument of type
    <code>conf_object_t *</code> is left out, as it corresponds to the C++
    class instance. With the C++ <code>override</code> keyword, compiler checks if
    the signature matches.
</p><p>

</p><h3 class="jdocu"><a name="Interface-method-implementation">7.2 Interface method implementation</a></h3>
<p>

</p><p>
    The interface method is called when the Simics interface is accessed. The
    implementation should handle the call in a device specific manner.
  </p><pre class="jdocu_small">exception_type_t sample_interface::operation(generic_transaction_t *mop,
                                             map_info_t info) {
    // implement behavior here
    return Sim_PE_No_Exception;
}
</pre><p>


</p><h3 class="jdocu"><a name="Interface-registration">7.3 Interface registration</a></h3>
<p>

</p><p>
    Interface is registered on the <code>ConfClass</code> object using the
    <code>add</code> function, just like registering a Simics attribute:
  </p><pre class="jdocu_small">void sample_interface::init_class(simics::ConfClass *cls) {
    cls-&gt;add(simics::iface::IoMemoryInterface::Info());
}
</pre><p>

</p><p>
    The only parameter is an instance of <code>IoMemoryInterface::Info</code>.
    It provides the registry support for the <code>io_memory</code>
    interface.
</p><p>
    For better data encapsulation, it is recommended to register the
    interface in the instance's static method <b><i>init_class</i></b>. 

</p><h3 class="jdocu"><a name="user-defined-interface">7.4 User defined interface</a></h3>
<p>
 
</p><p>
The C++ bindings for interfaces are only available for standard Simics
interfaces. To support user defined interfaces new C++ bindings in the form of
C++ interface classes must be generated. These classes can either be copied and
edited from existing headers, or generated from a Python program.
</p><p>
For example, <code>example-c.h</code> defines the type
<code>example_interface_t</code>.
 </p><pre class="jdocu_small">extern "C" {
    SIM_INTERFACE(example) {
        void (*iface_fun)(conf_object_t *obj);
    };
    #define EXAMPLE_INTERFACE "example"
}
</pre><p>

</p><p>
The C type <code>example_interface_t</code> needs to be converted to C++
type <code>ExampleInterface</code>. Simply run a Python program to convert
the C header file to a C++ header file which defines
<code>ExampleInterface</code>.
</p><pre class="jdocu_small">  python3 gen_cpp_interfaces.py -i example-c.h -o example-cc.h
</pre><p>
</p><p>
Now the <code>example-cc.h</code> can be included in the device model providing
<code>ExampleInterface</code>.
 </p><pre class="jdocu_small">#include "example-cc.h"

class sample_user_interface : public simics::ConfObject,
                              public simics::iface::ExampleInterface {
  public:
    explicit sample_user_interface(simics::ConfObjectRef o)
        : simics::ConfObject(o) { }

    static void init_class(simics::ConfClass *cls) {
        cls-&gt;add(ExampleInterface::Info());
    }

    // Interface method declarations
    void iface_fun() override {
        // TODO: implement
    }
};

extern "C" void init_local() {
    simics::make_class&lt;sample_user_interface&gt;(
            "sample_user_interface",
            "sample user interface",
            "N/A");
}
</pre><p>


</p><h3 class="jdocu"><a name="Port-registration">7.5 Port registration</a></h3>
<p>

</p><p>
Port objects are like normal Simics objects. A port class is declared by
inheriting from the <code>simics::Port</code> class and one or more interface
classes. The port class implements the C++ methods in the same way as the
C++ device class. The port class is then registered with its parent ConfClass
using the <code>add</code> function. The name of the port object is passed as the
second parameter to the <code>add</code> function. The registration of the port
class to its parent requires both classes are created. Thus the registration
should be placed inside the <b><i>init_local</i></b> function after the creation
of classes. A port array can be easily created using an array name as shown in
the example code.
</p><pre class="jdocu_small">class IoPort : public simics::Port&lt;sample_interface&gt;,
               public simics::iface::IoMemoryInterface {
  public:
    explicit IoPort(simics::ConfObjectRef o)
        : simics::Port&lt;sample_interface&gt;(o) {}

    static void init_class(simics::ConfClass *cls) {
        cls-&gt;add(simics::iface::IoMemoryInterface::Info());
    }

    // interface method declarations
    exception_type_t operation(generic_transaction_t *mem_op,
                               map_info_t map_info) override;
};

exception_type_t IoPort::operation(generic_transaction_t *mop,
                                   map_info_t info) {
    // implement behavior here
    return Sim_PE_No_Exception;
}

extern "C" void init_local() {
    auto cls = simics::make_class&lt;sample_interface&gt;(
            "sample_port_object",
            "sample interface with port",
            "N/A");
    auto port = simics::make_class&lt;IoPort&gt;(
            "sample_port_object.port",
            "sample port object port",
            "Sample port object port");

    // A single port under port namespace
    cls-&gt;add(port, "port.single");

    // A port array
    cls-&gt;add(port, "port.array[10]");
}
</pre><p>

</p><p>
If the port class needs to access the C++ parent class's internal state
variables, it can be defined inside the C++ parent class. There is a
help method <b><i>parent_data</i></b> that returns the parent object pointer.
</p><pre class="jdocu_small">class Parent : public simics::ConfObject {
  public:
    explicit Parent(simics::ConfObjectRef o)
        : simics::ConfObject(o) {}

    class IoPort : public simics::Port&lt;Parent&gt; {
      public:
        explicit IoPort(simics::ConfObjectRef o)
            : simics::Port&lt;Parent&gt;(o) {}
    };
};
</pre><p>

</p><p>

</p><h3 class="jdocu"><a name="Methods-collision">7.6 Methods collision</a></h3>
<p>

</p><p>
In C++, two overloaded functions must not have the same signature. In some
cases, methods collision can happen and could be resolved as shown in the
following example:
</p><pre class="jdocu_small">extern "C" {
SIM_INTERFACE(one) {
    void (*iface_fun)(conf_object_t*);
};
SIM_INTERFACE(another) {
    void (*iface_fun)(conf_object_t*);
};
}

namespace simics {
namespace iface {

class OneInterface {
  public:
    // Function override and implemented by user
    virtual void iface_fun() = 0;
};

class AnotherInterface {
  public:
    // Function override and implemented by user
    virtual void iface_fun() = 0;
};

}  // namespace iface
}  // namespace simics

class ImplementOne : public simics::iface::OneInterface {
    void iface_fun() override {
        // This is implementation for OneInterface
    }
};

class ImplementAnother : public simics::iface::AnotherInterface {
    void iface_fun() override {
        // This is implementation for AnotherInterface
    }
};

class MethodsCollision : public simics::ConfObject,
                         public ImplementOne,
                         public ImplementAnother {
  public:
    explicit MethodsCollision(simics::ConfObjectRef o)
        : simics::ConfObject(o) { }
};

</pre><p>

</p><p>


</p><h2 class="jdocu"><a name="Memory-Mappable-Object">8 Memory Mappable Object</a></h2>
<p>

</p><p>
</p><div class="note">
<b>Note:</b>
The C++ API to model a memory mapped object is currently considered as
tech-preview and may subject to change without notice.</div>Memory-mapped I/O (MMIO) devices are mapped to (associated with) an address
space with an address value. The device connects the data bus to the desired
device's hardware register. In C++, similar to the DML, several object types
like <code>bank</code>, <code>register</code> and <code>field</code> are provided to make
the connection and modeling easier.
<p>
<code>Bank</code> models a hardware register bank but can also contain unmapped
registers to help with the modeling. It contains a set of <code>register</code>s.
Each <code>register</code> is generally used to model a hardware register. A
<code>register</code> can be further divided into <code>field</code>s on the bit level.
As each type represent a memory hierarchy level based on the scope, they all
inherit from <b>HierarchicalObject</b> class. They are described
further in the sub sections.
</p><p>
A MMIO C++ device needs to include header <code>cc-modeling-api.h</code> and
inherit from <b>MappableConfObject</b> class instead of
<b>ConfObject</b> class. This class keeps track of the association
between the bank/register/field object's name and it's corresponding access
interface. This association is mainly useful for cross object access inside the
same device. For example, a register's access side-effect could be to update a
field in some other register. In this case, the access interface to that field
can be fetched from the association by its name. The access interface cannot be
overridden after the object is finalized.
</p><p>
</p><div class="note">
<b>Note:</b>
When overriding the <b><i>finalize</i></b>, remember to call the default
<b><i>finalize</i></b> of <b>MappableConfObject</b>.</div>The bit fields is by default represented in the little endian bit order, i.e,
bit number 0 is the least significant bit. It can be changed to big endian bit
order by override the function <b><i>big_endian_bitorder</i></b> from the device
class. This only affects how bits are represented but not the internal bits
implementation.
<p>
</p><h3 class="jdocu"><a name="Hierarchical-object">8.1 Hierarchical object</a></h3>
<p>

</p><p>
A device model in general consists of two parts from a design perspective: the
resource mapping information and the behavior of each resource that defines
what happens when accessed. The resource mapping information is used to route SW
access to the correct target. It usually consists of a bank with the offset and
size information of all the registers and fields. The resource is referred to as
a hierarchical object. Based on the level in the hierarchy, there are different
hierarchical objects including <code>bank</code>, <code>register</code> and
<code>field</code>. These concepts are the same as the concepts used in the DML.
</p><p>
All hierarchical objects in a device should have a unique name that begins with
the bank's name. The name should consist of a sequence of characters from the
character set [A–Z][a–z][0–9], underscore(<code>_</code>), square brackets
(<code>[]</code>) and dot (<code>.</code>). Square brackets should only be used to
represent items in an array. A dot (<code>.</code>) can only be used between
different hierarchical levels. For example, following names are invalid to use
as a hierarchical object's name:
<br>.bank_x
<br>bank[1].reg2.
<br>_x.._y
<br>*.reg_?.+
</p><p>
The hierarchical objects are created when a device instance is created. The user
has two options to provide the mapping: via the class hierarchy (in the code
itself) and as data (separate from the code). In the first option, the mapping
information is embedded in the class hierarchy together with the behavior. The
registers on a bank are defined inside a bank class with name, description,
offset, size, initial value and fields information if any. This mode looks
similar to how a corresponding DML device would look like.
</p><p>
In the second option, the bank/register/field resource mapping information is
provided as data using an arbitrary format. A data importer needs to convert the
data and call the C++ device API to register the mapping. This keeps the resource
mapping separated from its behavior and makes it possible to generate the data
from the register descriptions with the help of some code generators. Support for
these generators are outside the scope of the modeling library. This makes it 
possible to create an importer that reads the data from file, allowing the
mapping to be changed without recompiling the model.
</p><p>
The  method in the C++ device API to register the mapping requires the data in
the format of a <code>std::vector</code> of <code>simics::bank_t</code>. 
<code>simics::bank_t</code> contains the bank information includes a name, a
description and a list of registers. The registers are represented in a
<code>std::vector</code> of <code>simics::register_t</code> which includes a name, a
description, an offset, a size, an initial value and optionally a list of fields.
The fields are represented in another <code>std::vector</code> of
<code>simics::field_t</code> which includes a name, a description, a bit offset and
a bit width.
</p><p>
In the first option, the behavior is implemented in a subclass of 
<b>simics::BankRegister</b>. In the second option, the behavior can be
implemented in three ways:
1. If no customized behavior is registered, the default base class for the
corresponding resource is used;
2. Instantiation of one of the base classes providing standard behaviors;
3. Subclass one or more of the base classes.
</p><p>
Below is an example using the first option. Note that only the part related with
the mapping information registration is shown. In this way, the user needs to
write a bank class and register it on the device class using <b><i>add</i></b> and
<b><i>make_bank</i></b>. The <b><i>make_bank</i></b> function automatically registers
all bank required Simics interfaces. Inside the bank class, a new register
class is defined by inheriting the <b>simics::BankRegister</b> class and
overriding with the desired side effects behaviors.

 </p><pre class="jdocu_small">class SampleBank : public simics::BankPort&lt;SampleDevice&gt; {
  public:
    explicit SampleBank(simics::ConfObjectRef o)
        : simics::BankPort&lt;SampleDevice&gt;(o, nullptr) {}

    class SampleRegister : public simics::BankRegister&lt;SampleBank&gt; {
      public:
        using BankRegister::BankRegister;

        uint64_t read(uint64_t enabled_bytes) override {
            return 42;
        }
    };

  private:
    SampleRegister r0 {
        this, Name("r[0]"), Description("register always reads 42"),
        Offset(0), ByteSize(4), InitValue(42), {/* no fields */}
    };
    SampleRegister r1 {
        this, Name("r[1]"), Description("register always reads 42"),
        Offset(0x10), ByteSize(4), InitValue(42), {/* no fields */}
    };
};

void SampleDevice::init_class(simics::ConfClass *cls) {
    cls-&gt;add(simics::make_bank&lt;SampleBank&gt;(cls-&gt;name() + ".SampleBank",
                                            "sample bank"), "bank.b[2]");
</pre><p>

</p><p>
Below is another example using the second option. The mapping information for the
<b>SampleDeviceWithRegisterAsData</b> is registered by calling the 
method <b><i>import_data</i></b> from a data importer. Within the method,
<b><i>create_hierarchy_from_register_data</i></b> is called with the mapping data.
In the example, the mapping data is already provided of type
<code>std::vector&lt;simics::bank_t&gt;</code>. But in reality, it can be in
arbitrary format and convert into <code>std::vector&lt;simics::bank_t&gt;</code> by
the data importer. Each resource in the example will be assigned the default
behavior (read and write) except for register <code>b0.r1</code> which is defined as
a custom write-clear register.
</p><p>
</p><div class="note">
<b>Note:</b>
This example shows how to provide a customized class; for write-clear
  there is already a <b>Write1ClearsRegister</b> class in the modeling
  library.</div><pre class="jdocu_small">#include &lt;simics/mappable-conf-object.h&gt;
#include &lt;simics/register.h&gt;
#include &lt;simics/bank-port.h&gt;
#include &lt;vector&gt;

#include "register-as-data.h"

class SampleRegister : public simics::Register {
  public:
    using Register::Register;

    uint64_t read(uint64_t enabled_bytes) override {
        return 42;
    }
};

class DataImporter {
  public:
    explicit DataImporter(simics::MappableConfObject *obj)
        : obj_(obj) {}

    template &lt;typename T&gt;
    static void import_data(simics::ConfClass *cls) {
        simics::create_hierarchy_from_register_data&lt;T&gt;(cls, register_as_data);
    }

  private:
    simics::MappableConfObject *obj_;
    SampleRegister b0_r0 {obj_, "b[0].r[0]"};
    SampleRegister b0_r1 {obj_, "b[0].r[1]"};
    SampleRegister b1_r0 {obj_, "b[1].r[0]"};
    SampleRegister b1_r1 {obj_, "b[1].r[1]"};
};
</pre><p>


 </p><pre class="jdocu_small">#include &lt;simics/cc-api.h&gt;
#include &lt;simics/cc-modeling-api.h&gt;
#include "data-importer.h"

class SampleDeviceWithRegisterAsData : public simics::MappableConfObject,
                                       public DataImporter {
  public:
    explicit SampleDeviceWithRegisterAsData(simics::ConfObjectRef obj)
        : MappableConfObject(obj),
          DataImporter(this) {}

    static void init_class(simics::ConfClass *cls) {
        DataImporter::import_data&lt;SampleDeviceWithRegisterAsData&gt;(cls);
    }
};

extern "C" void init_sample_device_with_register_as_data() {
    simics::make_class&lt;SampleDeviceWithRegisterAsData&gt;(
            "sample_device_cpp_with_register_as_data",
            "sample C++ device",
            "This is a sample Simics device written in C++.");
}
</pre><p>

</p><p>
</p><h4 class="jdocu"><a name="Bank">8.1.1 Bank</a></h4>
<p>

</p><p>
A register bank (or simply bank) is an abstraction that is used to group
registers, and to expose these to the outside world. A bank is implemented as
a port object of the C++ device class. Registers are exposed to the rest of the
simulated system through the Simics <code>transaction</code> interface, and
exposed to scripting and user interfaces through the
<code>register_view</code>, <code>register_view_read_only</code> and
<code>bank_instrumentation_subscribe</code> Simics interfaces.
</p><p>
Banks can also be grouped into an array. Each element in the bank array
is a separate configuration object in Simics, and can thus be individually
mapped in a memory space. 
</p><p>
Simics configuration objects for bank instances are named like the bank but
with a <code>bank</code> prefix. For instance, if a device class has added a bank
with declaration <code>bank.regs[2]</code>, and a device instance is named
<code>dev</code> in Simics, then the two banks are represented in Simics by
configuration objects named <code>dev.bank.regs[0]</code> and
<code>dev.bank.regs[1]</code>.
</p><p>

</p><h4 class="jdocu"><a name="Register">8.1.2 Register</a></h4>
<p>

</p><p>
A register is an object that contains an integer value. Normally, a register
corresponds to a segment of consecutive locations in the address space of the
bank; however, it is also possible (and often useful) to have registers that
are not mapped to any address within the bank. All registers must be part of a
register bank.
</p><p>
The following information is needed in order to map a register to an address
space of the enclosing bank.
</p><p>
</p><ul>
  <li>Name</li>
  <li>Description</li>
  <li>Offset</li>
  <li>Size</li>
  <li>Initial value</li>
  <li>Fields(could be empty)</li>
</ul>
<p>
The name of a register follows the Simics naming rules. Description is a
short description of the register. Offset is the address of the bank where
the register is mapped at. The size is an integral, nonzero number of 8-bit
bytes. A single register cannot be wider than 8 bytes. The initial value
defines the register's value when the object is created. A register may be
optionally divided into several fields. The fields are described in the next
section.
</p><p>
To indicate an array, similar to a C array, specify the number of registers
between a pair of square brackets, e.g., <code>r[8]</code>. By default the stride of
the array is the size of the register, but other values can be chosen as follows,
<code>r[8 stride 4]</code>.
</p><p>
</p><h5 class="jdocu"><a name="Register-Attribute">8.1.2.1 Register Attribute</a></h5>
<p>

</p><p>
For every register, an attribute of integer type is automatically added to the
containing bank. The name of the register is used as the name of the attribute;
e.g., a register named <code>r1</code> will get a corresponding attribute on the
bank named <code>r1</code>. The register value is automatically saved when Simics
creates a checkpoint.

</p><h5 class="jdocu"><a name="Not-Mapping-Addresses-To-Registers">8.1.2.2 Not Mapping Addresses To Registers</a></h5>
<p>

An important thing to note is that registers do not have to be mapped at all.
This may be useful for internal registers that are not directly accessible from
software. By using an unmapped register, you can get the advantages of using
register, such as automatic checkpointing and register fields. This internal
register can then be used from the implementations of other registers, or other
parts of the model.
</p><p>
To create an unmapped register, simply instantiate a register of type
<b>UnmappedRegister</b> (or a subtype of it).


</p><h4 class="jdocu"><a name="Field">8.1.3 Field</a></h4>
<p>

Real hardware registers often have a number of fields with separate meaning.
For example, the lowest three bits of the register could be a status code, the
next six bits could be a set of flags, and the rest of the bits could be
reserved.
</p><p>
To make this easy to express, a <code>register</code> object can contain a number
of <code>field</code> objects. Each <code>field</code> corresponds to a bit range of
the enclosing register.
</p><p>
The value of a field is stored in the corresponding bits of the containing
register's storage. The easiest way to access the value of a register or field
is to use the <b><i>get</i></b> and <b><i>set</i></b> methods.
</p><p>
To indicate an array, similar to a C array, specify the number of fields
between a pair of square brackets, e.g., <code>f[8]</code>. By default the stride of
the array is the size of the field, but other values can be chosen as follows,
<code>f[8 stride 4]</code>.
</p><p>

</p><h4 class="jdocu"><a name="Standard-Templates">8.1.4 Standard Templates</a></h4>
<p>

</p><p>
This chapter describes the standard templates for C++ registers and fields.
</p><p>
Note that many standard templates have the same functionality and only differ by
name or log-messages printed when writing or reading them. The name of the
template helps developers to get a quick overview of the device functionality.
Two such examples are the <code>undocumented</code> and <code>reserved</code> templates.
Both have the same functionality. However, the <code>undocumented</code> template
hints that something in the device documentation is unclear or missing, and the
<code>reserved</code> template that the register or field should not be used by
software.
</p><p>
Software reads and writes are defined as accesses using the
<code>transaction</code> interface (write/reads to memory/io mapped device).
Software reads and writes use the built-in <b><i>read</i></b> and <b><i>write</i></b>
methods. Hardware access is defined as access made from within the model itself,
using either <b><i>set/get</i></b> for side-effect free access or
<b><i>read/write</i></b> for an access with side-effects.
</p><p>
</p><h5 class="jdocu"><a name="Templates-for-registers-and-fields">8.1.4.1 Templates for registers and fields</a></h5>
<p>

</p><p>
The read and write behaviour of registers and fields is in most cases
controlled by class inheritance and method overriding. The <b><i>read</i></b> and
<b><i>write</i></b> provided in <b>Register</b> and <b>Field</b>
is virtual and can be override by an implementation in a derived class. The
default implementation can still be referenced using a explicit namespace from
the base class.
</p><p>
The following templates are provided and most of them can be applied to both
registers and fields. The section use <code>object</code> as a combined name for
registers and fields. Most of them affect either the write or read operation;
if applied on a register it will disregard fields. For instance, when
inheriting from the <b>ReadUnimplRegister</b> class on a register with
fields, then the read will ignore any implementations of read overrides in
fields, and return the current register value (through <b><i>get</i></b>). However,
writes will still propagate to the fields.
</p><p>
<table>

  <tbody><tr><td class="jdocu_noborder">Class name</td><td class="jdocu_noborder">Description</td><td class="jdocu_noborder">Log output</td></tr>

  <tr>
    <td class="jdocu_noborder">IgnoreWriteRegister/IgnoreWriteField</td>
    <td class="jdocu_noborder">Writes are ignored. This template might also be useful for read-only
      fields inside an otherwise writable register. See the documentation for
      the <code>ReadOnlyRegister</code> template for more information.</td>
    <td class="jdocu_noborder">/</td>
  </tr>

  <tr>
    <td class="jdocu_noborder">Read0Register/Read0Field</td>
    <td class="jdocu_noborder">Reads return 0, regardless of register/field value. Writes are
      unaffected by this template.</td>
    <td class="jdocu_noborder">/</td>
  </tr>

  <tr>
    <td class="jdocu_noborder">ReadOnlyRegister/ReadOnlyField</td>
    <td class="jdocu_noborder">The object value is read-only for software, the object value can be
      modified by hardware.</td>
    <td class="jdocu_noborder">First software write results in a spec_violation log-message on
      log-level 1, remaining writes on log-level 2. Fields will only log if the
      written value is different from the old value.
<p>
      If the register containing the read-only field also contains writable
      fields, it may be better to use the <code>IgnoreWriteRegister</code> template
      instead, since software often do not care about what gets written to a
      read-only field, causing unnecessary logging.</p></td>
  </tr>

  <tr>
    <td class="jdocu_noborder">WriteOnlyRegister/WriteOnlyField</td>
    <td class="jdocu_noborder">The register value can be modified by software but can't be read back,
      reads return 0. Only for use on registers; use <code>ReadZeroField</code> for
      write-only fields. Reads return 0, regardless of register/field value.
      Writes are unaffected by this template.</td>
    <td class="jdocu_noborder">The first time the object is read there is a spec_violation
      log-message on log-level 1, remaining reads on log-level 2.</td>
  </tr>

  <tr>
    <td class="jdocu_noborder">Write1ClearsRegister/Write1ClearsField</td>
    <td class="jdocu_noborder">Software can only clear bits. This feature is often used when
      hardware sets bits and software clears them to acknowledge.
      Software write 1's to clear bits. The new object value is
      a bitwise AND of the old object value and the bitwise
      complement of the value written by software.</td>
    <td class="jdocu_noborder">/</td>
  </tr>

  <tr>
    <td class="jdocu_noborder">ClearOnReadRegister/ClearOnReadField</td>
    <td class="jdocu_noborder">Software reads return the object value. The object value is then reset
      to 0 as a side-effect of the read.</td>
    <td class="jdocu_noborder">/</td>
  </tr>

  <tr>
    <td class="jdocu_noborder">Write1OnlyRegister/Write1OnlyField</td>
    <td class="jdocu_noborder">Software can only set bits to 1. The new object value is the bitwise
      OR of the old object value and the value written by software.</td>
    <td class="jdocu_noborder">/</td>
  </tr>

  <tr>
    <td class="jdocu_noborder">Write0OnlyRegister/Write0OnlyField</td>
    <td class="jdocu_noborder">Software can only set bits to 0. The new object value is the bitwise
      AND of the old object value and the value written by software.</td>
    <td class="jdocu_noborder">/</td>
  </tr>

  <tr>
    <td class="jdocu_noborder">ReadConstantRegister/ReadConstantField</td>
    <td class="jdocu_noborder">Reads return a constant value.
<p>
      Writes are unaffected by this template. The read value is unaffected
      by the value of the register or field.
</p><p>
      The template is intended for registers or fields that have a stored value
      that is affected by writes, but where reads disregard the stored value
      and return a constant value. The attribute for the register will reflect
      the stored value, not the value that is returned by read operations. For
      constant registers or fields that do not store a value, use the
      <code>Constant</code> template instead.</p></td>
    <td class="jdocu_noborder">/</td>
  </tr>

  <tr>
    <td class="jdocu_noborder">ConstantRegister/ConstantField</td>
    <td class="jdocu_noborder">Writes are forbidden and have no effect.
<p>
      The object still has backing storage, which affects the value being read.
      Thus, an end-user can modify the constant value by writing to the
      register's attribute. Such tweaks will survive a reset.
</p><p>
      Using the <code>Constant</code> template marks that the object is intended to
      stay constant, so the model should not update the register value, and not
      override the <b><i>read</i></b> method. Use the template <code>ReadOnly</code>
      if that is desired.</p></td>
    <td class="jdocu_noborder">First write to register or field (if field value is not
      equal to write value) results in a spec_violation log-message on
      log-level 1, remaining writes on log-level 2.</td>
  </tr>

  <tr>
    <td class="jdocu_noborder">SilentConstantRegister/SilentConstantField</td>
    <td class="jdocu_noborder">The object value will remain constant. Writes are ignored and do not
      update the object value.
<p>
      The end-user can tweak the constant value; any tweaks will survive a
      reset.
</p><p>
      By convention, the object value should not be modified by the model; if
      that behaviour is wanted, use the <code>IgnoreWrite</code> template instead.
    </p></td>
    <td class="jdocu_noborder">/</td>
  </tr>

  <tr>
    <td class="jdocu_noborder">ZerosRegister/ZerosField</td>
    <td class="jdocu_noborder">The object value is constant 0. Software writes are forbidden and do
      not update the object value.</td>
    <td class="jdocu_noborder">First software write to register or field (if field value is not
      equal to write value) results in a spec_violation log-message on
      log-level 1, remaining writes on log-level 2.</td>
  </tr>

  <tr>
    <td class="jdocu_noborder">OnesRegister/OnesField</td>
    <td class="jdocu_noborder">The object is constant all 1's. Software writes do not update the
      object value. The object value is all 1's.</td>
    <td class="jdocu_noborder">First software write to register or field (if field value is not
      equal to write value) results in a spec_violation log-message on
      log-level 1, remaining writes on log-level 2.</td>
  </tr>

  <tr>
    <td class="jdocu_noborder">IgnoreRegister/IgnoreField</td>
    <td class="jdocu_noborder">The object's functionality is unimportant. Reads return 0.
      Writes are ignored.</td>
    <td class="jdocu_noborder">/</td>
  </tr>

  <tr>
    <td class="jdocu_noborder">ReservedRegister/ReservedField</td>
    <td class="jdocu_noborder">The object is marked reserved and should not be used by software.
      Writes update the object value. Reads return the object value.</td>
    <td class="jdocu_noborder">First software write to register or field (if field value is not
      equal to write value) results in a `spec-viol` log-message on
      log-level 2. No logs on subsequent writes.</td>
  </tr>

  <tr>
    <td class="jdocu_noborder">UnimplRegister/UnimplField</td>
    <td class="jdocu_noborder">The object functionality is unimplemented. Warn when software is using
      the object. Writes and reads are implemented as default writes and reads.
    </td>
    <td class="jdocu_noborder">First read from a register results in an unimplemented log-message on
      log-level 1, remaining reads on log-level 3. Reads from a field does
      not result in a log-message. First write to a register results in
      an unimplemented log-message on log-level 1, remaining writes on
      log-level 3. First write to a field (if field value is not equal to
      write value) results in an unimplemented log-message on log-level 1,
      remaining writes on log-level 3.</td>
  </tr>

  <tr>
    <td class="jdocu_noborder">ReadUnimplRegister/ReadUnimplField</td>
    <td class="jdocu_noborder">The object functionality associated to a read access is unimplemented.
      Write access is using default implementation and can be overridden (for
      instance by the <code>ReadOnly</code> template).</td>
    <td class="jdocu_noborder">First software read to a register results in an unimplemented
      log-message on log-level 1, remaining reads on log-level 3. Software
      reads to fields does not result in a log-message.</td>
  </tr>

  <tr>
    <td class="jdocu_noborder">WriteUnimplRegister/WriteUnimplField</td>
    <td class="jdocu_noborder">The object functionality associated to a write access is unimplemented.
      Read access is using default implementation and can be overridden (for
      instance by the <code>WriteOnly</code> template).</td>
    <td class="jdocu_noborder">First software write to registers results in an unimplemented
      log-message on log-level 1, remaining writes on log-level 3.  First write
      to a field (if field value is not equal to write value) results in an
      unimplemented log-message on log-level 1, remaining writes on log-level
      3.</td>
  </tr>

  <tr>
    <td class="jdocu_noborder">SilentUnimplRegister/SilentUnimplField</td>
    <td class="jdocu_noborder">The object functionality is unimplemented, but do not print a
      lot of log-messages when reading or writing.
      Writes and reads are implemented as default writes and reads.</td>
    <td class="jdocu_noborder">First software read to a register results in an unimplemented
      log-message on log-level 2, remaining reads on log-level 3. Software
      reads to fields does not result in a log-message. First software write
      to a register results in an unimplemented log-message on log-level 2,
      remaining writes on log-level 3. First write to a field (if field value
      is not equal to write value) results in an unimplemented log-message on
      log-level 2, remaining writes on log-level 3.</td>
  </tr>

  <tr>
    <td class="jdocu_noborder">UndocumentedRegister/UndocumentedField</td>
    <td class="jdocu_noborder">The object functionality is undocumented or poorly documented.
      Writes and reads are implemented as default writes and reads.</td>
    <td class="jdocu_noborder">First software write and read result in a spec_violation log-message on
      log-level 1, remaining on log-level 2.</td>
  </tr>

  <tr>
    <td class="jdocu_noborder">UnmappedRegister</td>
    <td class="jdocu_noborder">The register is excluded from the address space of the containing bank.
    </td>
    <td class="jdocu_noborder">/</td>
  </tr>

  <tr>
    <td class="jdocu_noborder">DesignLimitationRegister/DesignLimitationField</td>
    <td class="jdocu_noborder">The object's functionality is not in the model's scope and has been
      left unimplemented as a design decision. Software and hardware
      writes and reads are implemented as default writes and reads.
      Debug registers are a prime example of when to use this
      template. This is different from <em>unimplemented</em> which is
      intended to be implement (if required) but is a limitation in
      the current model.</td>
    <td class="jdocu_noborder">/</td>
  </tr>

  <tr>
    <td class="jdocu_noborder">AliasRegister</td>
    <td class="jdocu_noborder">The register is an alias for another register. All operations are
      forwarded to the other register.
    </td>
    <td class="jdocu_noborder">/</td>
  </tr>

</tbody></table>

</p><p>



</p><h2 class="jdocu"><a name="Migration-Guide">9 Migration Guide</a></h2>
<p>

</p><p>
From a device model's point of view there are only a few incompatible changes
between Simics C++ API v1 and v2 to consider. Migration should thus be straight
forward and trivial.
</p><p>
Here is the list of known changes that can cause problems when migrating from
Simics C++ API v1:
</p><p>
</p><ul>
  <li>Set <code>USE_CC_API</code> to 2 in the Makefile.</li>
  <li>The header to include has been changed to
    <code>simics/cc-api.h</code> instead of
    <code>simics/c++/device-api.h</code>.</li>
  <li>A model-defined class inherits from the <code>simics::ConfObject</code>
    class instead of <code>simics::SimicsObject</code>.</li>
  <li>The C++ class constructor argument type is changed to
    <code>simics::ConfObjectRef</code> instead of
    <code>simics::SimicsObjectRef</code>. </li>
  <li>Method <b><i>simics_obj</i></b> of <code>ConfObject</code> has been renamed
    to <b><i>obj</i></b>. </li>
  <li>Use <b><i>make_class</i></b> to register a class. The parameters are
    same as the previous <code>ClassDef</code>. </li>
  <li>Simics attribute registration uses only one type,
    <code>simics::Attribute</code>.</li>
  <li>Add attributes, interfaces, port objects and log groups via the
    <b><i>add</i></b> method. </li>
  <li>Interfaces are registered with the help of an interface info class.</li>
  <li>Port interface is no longer supported. Use port object instead. </li>
  <li>The model-defined class is recommended to register its property through
    its static function <b><i>init_class</i></b>, but can use the old way of
    registering everything in the <b><i>init_local</i></b> static function</li>
  <li>The state variable set function, i.e. the attribute setter, should
    return <code>void</code> instead of <code>simics::SetResult</code>.</li>
  <li>There is no need for <code>state_mapper</code> anymore. Any existing
    <code>state_mapper</code> is dead code and can be removed. </li>
</ul>
<p>

</p><p>

</p><h2 class="jdocu"><a name="Notices-amp-Disclaimers">10 Notices &amp; Disclaimers</a></h2>
<p>

</p><p>
</p><div class="jdocu_copyright">
<p>
No product or component can be absolutely secure.
</p><p>
Intel technologies may require enabled hardware, software or
service activation.
</p><p>
Your costs and results may vary.
</p><p>
Intel does not control or audit third-party data. You should
consult other sources to evaluate accuracy.
</p><p>
You may not use or facilitate the use of this document in
connection with any infringement or other legal analysis concerning
Intel products described herein. You agree to grant Intel a
non-exclusive, royalty-free license to any patent claim thereafter
drafted which includes subject matter disclosed herein.
</p><p>
No license (express or implied, by estoppel or otherwise) to any
intellectual property rights is granted by this document.
</p><p>
All product plans and roadmaps are subject to change without
notice.
</p><p>
The products described may contain design defects or errors known
as errata which may cause the product to deviate from published
specifications. Current characterized errata are available on
request.
</p><p>
Intel disclaims all express and implied warranties, including
without limitation, the implied warranties of merchantability, fitness
for a particular purpose, and non-infringement, as well as any
warranty arising from course of performance, course of dealing, or
usage in trade.
</p><p>
© 2010–2022 Intel Corporation. Intel, the Intel logo,
and other Intel marks are trademarks of Intel Corporation or its
subsidiaries. Other names and brands may be claimed as the property of
others.
</p><p>


</p></div>
<p>

</p><div class=chain>
<span></span>
</div>
